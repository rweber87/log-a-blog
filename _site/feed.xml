<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-03-24T08:27:29-04:00</updated><id>http://localhost:4000/</id><title type="html">Log-A-Blog</title><subtitle>Writing about code stuff and how it works
</subtitle><entry><title type="html">DBMS - What is it and which is right for me?</title><link href="http://localhost:4000/jekyll/update/2017/03/23/welcome-to-jekyll.html" rel="alternate" type="text/html" title="DBMS - What is it and which is right for me?" /><published>2017-03-23T15:30:04-04:00</published><updated>2017-03-23T15:30:04-04:00</updated><id>http://localhost:4000/jekyll/update/2017/03/23/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2017/03/23/welcome-to-jekyll.html">&lt;p&gt;DBMS stands for database management system (acronyms ftw!). Simply put it’s a way for users to interact with data. A common misconception when learning about DBMS is referring to them as the database itself. It’s actually an intermediary between the user, data, and other applications to capture and analyze data sets. During your journey as a developer you will likely reach a moment where you’ll need to ask youself “self: which DBMS should I use?” My goal is to shine some light on the pro’s and cons of some popular ones that are out there for you to better reach that conclusion on your own.&lt;/p&gt;

&lt;p&gt;Three examples of commonly used DBMS’ in today’s development world are SQLite, MySQL, and MongoDB.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rweber87.github.io/log-a-blog/assets/SQLite.png&quot; alt=&quot;SQLite&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SQLite is a neat little &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database_management_system&quot;&gt;RDBMS&lt;/a&gt; released in 2000. A unique aspect of SQLite is it is embedded in the application running SQL as opposed to a client server database engine. This means it is tightly integrated in the application and makes calls to files that contain the data locally as opposed to a server. That alone makes SQLite very cimpact and portable for basic querying analysis, but at a cost.&lt;/p&gt;

&lt;p&gt;Because of how portabile this DBMS is it’s ability to handle &lt;a href=&quot;https://en.wikipedia.org/wiki/Multi-user&quot;&gt;multi-user&lt;/a&gt; applications are limited. If you’re looking for scalable DBMS’s that can handle multiple users or high writing volume this one is likely not a good fit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rweber87.github.io/log-a-blog/assets/MySQL.png&quot; alt=&quot;MySQL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MySQL is ranked #2 in terms &lt;a href=&quot;http://db-engines.com/en/ranking_trend&quot;&gt;popularity&lt;/a&gt; just behind Oracle. As you might have assumed, MySQL is built to handle larger volumes of data and users.  It comes with many of the standard SQL features one would expect when using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_database_management_system&quot;&gt;RDBMS&lt;/a&gt;  and also comes with a more advanced built-in security interface.&lt;/p&gt;

&lt;p&gt;Limitations when considering MySQL is it’s inflexible nature at using storage engines other than the default InnoDB. You give up some of the standard SQL functionality when using other databases &lt;a href=&quot;https://en.wikipedia.org/wiki/MySQL&quot;&gt;“including foreign key references and check constraints.”&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The general consensus seems that MySQL’s ease of use through open-sourced tools has helped it reach the level of popularity it has gained today.&lt;/p&gt;

&lt;p&gt;A few companies currently utilizing MySQL include sites such as &lt;code class=&quot;highlighter-rouge&quot;&gt;Google, Facebook, Twitter, Flickr, and YouTube&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rweber87.github.io/log-a-blog/assets/MongoDB.png&quot; alt=&quot;MongoDB&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The key difference that sets the other reviewed DBMS from Mongo is it is a &lt;em&gt;NoSQL document-oriented database program&lt;/em&gt; (now that’s a mouthful!). What does that mean exactly? Well let’s break it down:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NoSQL - Does not imply what you might think. The “No” actually stands for Not Only. In other words SQL isn’t the only language accepted to write queries. All that being said, Mongo does &lt;em&gt;not&lt;/em&gt; support SQL when running queries.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Document-oriented database implies that, unlike it’s sibling relational databases (table based), all of our data can be stored in one single instance in the database. This allows the task of mapping to be quite flexible. &lt;a href=&quot;http://docs.couchbase.com/developer/dev-guide-3.0/compare-docs-vs-relational.html&quot;&gt;Here’s a great article talking about some differences between document oriented vs. relational oriented databases.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally, the syntax of writing Mongo queries are quite different from SQL and seem very method like.&lt;/p&gt;

&lt;p&gt;A standard SQL query such as…&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;no&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inventory&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;D&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Would be re-written as…&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;inventory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;status: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;D&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Mongo also supports a vast majority of popular langues out there…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rweber87.github.io/log-a-blog/assets/MongoLanguages.jpg&quot; alt=&quot;MongoDBLanguages&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Some downsides to this language (which is entirely subjective): the lack of structure makes it difficult to standaradize for users. There also lacks a good security configuration which resulted in DB’s being stolen and held for randsom.&lt;/p&gt;

&lt;p&gt;All-in-all it’s really up to you and the application you’re trying to build. In my opnion it seems best to start small and work your way up as needed, but don’t wait too long to upgrade or integrating a new system to fit your needs could prove to be quite difficult.&lt;/p&gt;

&lt;p&gt;Here’s a fun mapping of Facebook’s class design. Enjoy!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rweber87.github.io/log-a-blog/assets/facebookschema.jpg&quot; alt=&quot;FacebookSchema&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://web.archive.org/web/20121031052327/http://blogs.x2line.com/al/archive/2007/06/02/3124.aspx&quot;&gt;source&lt;/a&gt;&lt;/p&gt;

&lt;!-- Mapping for links :D [jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
 --&gt;</content><author><name></name></author><summary type="html">DBMS stands for database management system (acronyms ftw!). Simply put it’s a way for users to interact with data. A common misconception when learning about DBMS is referring to them as the database itself. It’s actually an intermediary between the user, data, and other applications to capture and analyze data sets. During your journey as a developer you will likely reach a moment where you’ll need to ask youself “self: which DBMS should I use?” My goal is to shine some light on the pro’s and cons of some popular ones that are out there for you to better reach that conclusion on your own.</summary></entry></feed>